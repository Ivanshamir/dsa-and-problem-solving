In computer programming, there are various data structures that are used to store and manage collections of data efficiently. Among them, stack, queue, and deque are some of the most commonly used data structures. These data structures are widely used in JavaScript programming, and they offer several benefits that make them invaluable in certain situations.

Stack

A stack is a simple data structure that operates on the Last In First Out (LIFO) principle. In JavaScript, it is implemented as an array with two primary operations: push() and pop(). The push() operation adds an element to the top of the stack, while the pop() operation removes the top element from the stack.

Stacks are commonly used in algorithms that involve recursion, as they allow for the efficient tracking of function calls. Additionally, they are used in undo-redo functionality in text editors and other software.

Here's an example of a stack implementation in JavaScript:
```
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class Stack {
  constructor() {
    this.top = null;
    this.size = 0;
  }

  push(value) {
    const newNode = new Node(value);
    newNode.next = this.top;
    this.top = newNode;
    this.size++;
  }

  pop() {
    if (this.isEmpty()) {
      return "Underflow";
    }
    const removedNode = this.top;
    this.top = removedNode.next;
    this.size--;
    return removedNode.value;
  }

  peek() {
    if (this.isEmpty()) {
      return "No elements in Stack";
    }
    return this.top.value;
  }

  isEmpty() {
    return this.size === 0;
  }

  printStack() {
    let str = "";
    let currentNode = this.top;
    while (currentNode) {
      str += currentNode.value + " ";
      currentNode = currentNode.next;
    }
    return str;
  }
}
```

Queue

A queue is another basic data structure that operates on the First In First Out (FIFO) principle. In JavaScript, it is implemented as an array with two primary operations: enqueue() and dequeue(). The enqueue() operation adds an element to the rear of the queue, while the dequeue() operation removes the element from the front of the queue.

Queues are widely used in scheduling and task management applications. Additionally, they are used in breadth-first search algorithms, where the nodes are explored in a level-wise manner.

Here's an example of a queue implementation in JavaScript:
```
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class Queue {
  constructor() {
    this.front = null;
    this.rear = null;
    this.size = 0;
  }

  enqueue(value) {
    const newNode = new Node(value);
    if (this.isEmpty()) {
      this.front = newNode;
      this.rear = newNode;
    } else {
      this.rear.next = newNode;
      this.rear = newNode;
    }
    this.size++;
  }

  dequeue() {
    if (this.isEmpty()) {
      return "Underflow";
    }
    const removedNode = this.front;
    this.front = removedNode.next;
    if (!this.front) {
      this.rear = null;
    }
    this.size--;
    return removedNode.value;
  }

  frontElement() {
    if (this.isEmpty()) {
      return "No elements in Queue";
    }
    return this.front.value;
  }

  isEmpty() {
    return this.size === 0;
  }

  printQueue() {
    let str = "";
    let currentNode = this.front;
    while (currentNode) {
      str += currentNode.value + " ";
      currentNode = currentNode.next;
    }
    return str;
  }
}
```


Deque

A deque, short for double-ended queue, is a data structure that allows for the insertion and removal of elements from both ends. In JavaScript, it is implemented as an array with several primary operations, including push(), pop(), unshift(), and shift().

Deques are commonly used in algorithms that require the processing of data from both ends, such as palindromic strings, sliding windows, and caching.

Here's an example of a deque implementation in JavaScript:
```
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
    this.previous = null;
  }
}

class Deque {
  constructor() {
    this.front = null;
    this.rear = null;
    this.size = 0;
  }

  addFront(value) {
    const newNode = new Node(value);
    if (this.isEmpty()) {
      this.front = newNode;
      this.rear = newNode;
    } else {
      newNode.next = this.front;
      this.front.previous = newNode;
      this.front = newNode;
    }
    this.size++;
  }

  addRear(value) {
    const newNode = new Node(value);
    if (this.isEmpty()) {
      this.front = newNode;
      this.rear = newNode;
    } else {
      newNode.previous = this.rear;
      this.rear.next = newNode;
      this.rear = newNode;
    }
    this.size++;
  }

  removeFront() {
    if (this.isEmpty()) {
      return "Underflow";
    }
    const removedNode = this.front;
    this.front = removedNode.next;
    if (!this.front) {
        this.rear = null;
    } else {
        this.front.previous = null;
    }
    this.size--;
    return removedNode.value;
    }

    removeRear() {
        if (this.isEmpty()) {
            return "Underflow";
        }
        const removedNode = this.rear;
        this.rear = removedNode.previous;
        if (!this.rear) {
            this.front = null;
        } else {
            this.rear.next = null;
        }
        this.size--;
        return removedNode.value;
    }

    peekFront() {
        if (this.isEmpty()) {
            return "No elements in Deque";
        }
        return this.front.value;
    }

    peekRear() {
        if (this.isEmpty()) {
            return "No elements in Deque";
        }
        return this.rear.value;
    }

    isEmpty() {
        return this.size === 0;
    }

    printDeque() {
    let str = "";
    let currentNode = this.front;
    while (currentNode) {
    str += currentNode.value + " ";
    currentNode = currentNode.next;
    }
    return str;
    }
}
```